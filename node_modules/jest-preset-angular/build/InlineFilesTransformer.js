"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.factory = exports.version = exports.name = void 0;
const TransformUtils_1 = require("./TransformUtils");
const TEMPLATE_URL = 'templateUrl';
const STYLE_URLS = 'styleUrls';
const TEMPLATE = 'template';
const REQUIRE = 'require';
const TRANSFORM_PROPS = [TEMPLATE_URL, STYLE_URLS];
exports.name = 'angular-component-inline-files';
exports.version = 1;
function factory(cs) {
    const ts = cs.compilerModule;
    const createStringLiteral = TransformUtils_1.getCreateStringLiteral(ts);
    function isPropertyAssignmentToTransform(node) {
        return ts.isPropertyAssignment(node) && ts.isIdentifier(node.name) && TRANSFORM_PROPS.includes(node.name.text);
    }
    function transfromPropertyAssignmentForJest(node) {
        const mutableAssignment = ts.getMutableClone(node);
        const assignmentNameText = mutableAssignment.name.text;
        switch (assignmentNameText) {
            case TEMPLATE_URL:
                let pathLiteral = mutableAssignment.initializer;
                if (ts.isStringLiteral(pathLiteral)) {
                    if (pathLiteral.text && !pathLiteral.text.match(/^(\.\/|\.\.\/|\/)/)) {
                        pathLiteral = createStringLiteral(`./${pathLiteral.text}`);
                    }
                }
                const requireCall = ts.createCall(ts.createIdentifier(REQUIRE), undefined, [pathLiteral]);
                mutableAssignment.name = ts.createIdentifier(TEMPLATE);
                mutableAssignment.initializer = requireCall;
                break;
            case STYLE_URLS:
                mutableAssignment.initializer = ts.createArrayLiteral();
                break;
            default:
                break;
        }
        return mutableAssignment;
    }
    function createVisitor(ctx, _) {
        const visitor = (node) => {
            let resultNode = node;
            if (isPropertyAssignmentToTransform(node)) {
                resultNode = transfromPropertyAssignmentForJest(node);
            }
            resultNode = ts.visitEachChild(resultNode, visitor, ctx);
            return resultNode;
        };
        return visitor;
    }
    return (ctx) => (sf) => ts.visitNode(sf, createVisitor(ctx, sf));
}
exports.factory = factory;
