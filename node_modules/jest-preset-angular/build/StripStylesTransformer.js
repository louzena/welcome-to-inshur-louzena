"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.factory = exports.version = exports.name = void 0;
const STYLES = 'styles';
const COMPONENT = 'Component';
const TRANSFORM_IN_DECORATOR_PROPS = [STYLES];
exports.name = 'angular-component-strip-styles';
exports.version = 1;
function factory(cs) {
    const ts = cs.compilerModule;
    function isInDecoratorPropertyAssignmentToTransform(node) {
        return getInDecoratorPropertyAssignmentsToTransform(node).length > 0;
    }
    function getInDecoratorPropertyAssignmentsToTransform(node) {
        if (!ts.isClassDeclaration(node) || !node.decorators) {
            return [];
        }
        return node.decorators
            .map((dec) => dec.expression)
            .filter(ts.isCallExpression)
            .filter((callExpr) => ts.isIdentifier(callExpr.expression) && callExpr.expression.getText() === COMPONENT)
            .reduce((acc, nxtCallExpr) => Array.prototype.concat.apply(acc, nxtCallExpr.arguments.filter(ts.isObjectLiteralExpression).reduce((acc, nxtArg) => Array.prototype.concat.apply(acc, nxtArg.properties
            .filter(ts.isPropertyAssignment)
            .filter((propAss) => ts.isIdentifier(propAss.name) && TRANSFORM_IN_DECORATOR_PROPS.includes(propAss.name.text))), [])), []);
    }
    function transformStylesAssignmentForJest(node) {
        const mutableNode = ts.getMutableClone(node);
        const assignments = getInDecoratorPropertyAssignmentsToTransform(mutableNode);
        assignments.forEach((assignment) => {
            if (assignment.name.text === STYLES) {
                assignment.initializer = ts.createArrayLiteral();
            }
        });
        return mutableNode;
    }
    function createVisitor(ctx, _) {
        const visitor = (node) => {
            if (isInDecoratorPropertyAssignmentToTransform(node)) {
                return transformStylesAssignmentForJest(node);
            }
            else {
                return ts.visitEachChild(node, visitor, ctx);
            }
        };
        return visitor;
    }
    return (ctx) => (sf) => ts.visitNode(sf, createVisitor(ctx, sf));
}
exports.factory = factory;
